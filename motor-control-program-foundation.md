# 9.7 28BYJ-48 步进电机控制程序基础

解决了精度问题，让我们再次回到我们的电机控制程序上吧。上面给出的两个例程都不是实用的程序，为什么？因为程序中存在大段的延时，而在延时的时候是什么其它的事都干不了的，想想第二个程序，整整200秒什么别的事都干不了，这在实际的控制系统中是绝对不允许的。那么怎么改造一下呢？当然还是用定时中断来完成了，既然每个节拍持续时间是 2 ms，那我们直接用定时器定时 2 ms 来刷新节拍就行了。改造后的程序如下：

```
#include <reg52.h>
unsigned long beats = 0; //电机转动节拍总数
void StartMotor(unsigned long angle);
void main(){
    EA = 1;  //使能总中断
    TMOD = 0x01; //设置 T0 为模式1
    TH0 = 0xF8; //为 T0 赋初值 0xF8CD，定时 2 ms
    TL0 = 0xCD;
    ET0 = 1; //使能 T0 中断
    TR0 = 1; //启动 T0
    StartMotor(360*2+180); //控制电机转动2圈半
    while (1);
}
/* 步进电机启动函数，angle-需转过的角度 */
void StartMotor(unsigned long angle){
    //在计算前关闭中断，完成后再打开，以避免中断打断计算过程而造成错误
    EA = 0;
    beats = (angle * 4076) / 360; //实测为4076拍转动一圈
    EA = 1;
}
/* T0 中断服务函数，用于驱动步进电机旋转 */
void InterruptTimer0() interrupt 1{
    unsigned char tmp;  //临时变量
    static unsigned char index = 0; //节拍输出索引
    unsigned char code BeatCode[8] = { //步进电机节拍对应的 IO 控制代码
        0xE, 0xC, 0xD, 0x9, 0xB, 0x3, 0x7, 0x6
    };

    TH0 = 0xF8; //重新加载初值
    TL0 = 0xCD;
    //节拍数不为 0 则产生一个驱动节拍
    if (beats != 0){
        tmp = P1; //用 tmp 把 P1 口当前值暂存
        tmp = tmp & 0xF0; //用&操作清零低4位
        //用|操作把节拍代码写到低4位
        tmp = tmp | BeatCode[index];
        //把低4位的节拍代码和高4位的原值送回 P1
        P1 = tmp;
        index++; //节拍输出索引递增
        index = index & 0x07; //用&操作实现到8归零
        beats--; //总节拍数-1
    }else{ //节拍数为0则关闭电机所有的相
        P1 = P1 | 0x0F;
    }
}
```

程序还是比较简单的，电机转动的启动函数 StartMotor 只负责计算一个需要的总节拍数 beats，然后在中断函数内检测这个变量，不为0时就执行节拍操作，同时将其减1，直到减到0为止。

这里，我们要特别说明一下的是 StartMotor 函数中对 EA 的两次操作。我们可以看到对 beats 的赋值计算语句是夹在 EA=0;EA=1;这两行语句中间的，也就是说这行赋值计算语句在执行前先关闭了中断，而等它执行完后，才又重新打开了中断。在它执行过程中单片机是不会响应中断的，即中断函数 InterruptTimer0 不会被执行，即使这时候定时器溢出了，中断发生了，也只能等待 EA 重新置1后，才能得到响应，中断函数 InterruptTimer0 才会被执行。

那么为什么要这么做呢？我们来想一下：在本书开始我们就曾提到，我们所使用的 STC89C52 单片机是8位单片机，这个8位的概念就是说单片机操作数据时都是按8位即按1个字节进行的，那么要操作多个字节（不论是读还是写）就必须分多次进行了。而我们程序中定义的 beats 这个变量是 unsigned long 型，它要占用4个字节，那么对它的赋值最少也要分4次才能完成了。我们想象一下，假如在完成了其中第一个字节的赋值后，恰好中断发生了，InterruptTimer0 函数得到执行，而这个函数内可能会对 beats 进行减1的操作，减法就有可能发生借位，借位就会改变其它的字节，但因为此时其它的字节还没有被赋入新值，于是错误就会发生了，减1所得到的结果就不是预期的值了！所以要避免这种错误的发生就得先暂时关闭中断，等赋值完成后再打开中断。而如果我们使用的是 char 或 bit 型变量的话，因为它们都是在 CPU 的一次操作中就完成的，所以即使不关中断，也不会发生错误。问题分析清楚了，如何取舍还得根据实际情况来，遇上这类问题的时候多多考虑考虑吧。